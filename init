#!/usr/bin/env python3

import configparser
import imp
import logging
import os
import re
import shlex
import socket
import subprocess
import sys
import glob
import getpass
path = imp.load_source('path', 'lib/path')

def send(msg):
    log.info('>{}'.format(msg))
    s.send('{}\r\n'.format(msg).encode('utf-8'))

def recv():
    msg = sf.readline()
    log.info('<{}'.format(msg.rstrip()))
    return msg

def parse_msg(msg):
    match = MSG_RE.match(msg)
    if match:
        return (match.group('prefix'), match.group('command'),
                match.group('params'), match.group('trail'))
    else:
        return (None, None, None, None)

def parse_prefix(prefix):
    match = PREFIX_RE.match(prefix)
    if match:
        return (match.group('nick'), match.group('user'), match.group('host'))
    else:
        return (None, None, None)

def is_ignored(nick):
    try:
        with open('etc/ignore', 'r') as f:
            for line in f:
                if line.rstrip() == nick:
                    return True
    except OSError:
        pass
    return False

def sanitize_path(path):
    return path.replace('/', '')

def open_cmd_fifo():
    try:
        os.mkfifo('var/cmd')
    except OSError:
        pass
    return os.fdopen(os.open('var/cmd', os.O_RDONLY | os.O_NONBLOCK), 'r')

def run(commandline, env):
    commands = [re.sub(r'\\\|', '|', s) for s in re.split(r'(?<!\\)\|', commandline)]

    if len(commands)-1 > MAXPIPES:
        return (255, '', 'exceeded maximum number of pipes ({})'.format(MAXPIPES))

    processes = []

    for i, command in enumerate(commands):

        if i == 0:
            stdin = subprocess.DEVNULL
        else:
            stdin = processes[i - 1].stdout

        try:
            argv = shlex.split(command)
        except ValueError as e:
            return (255, '', str(e))

        if '>>' in argv:
            j = argv.index('>>')
            argv.pop(j)
            try:
                chan_path = path.chan_path(env['CHAN'], argv.pop(j))
                stdout = open(chan_path, 'a+')
            except IndexError:
                return (255, '', 'bad redirect')
            except OSError as e:
                return (e.errno, '', str(e))
        else:
            stdout = subprocess.PIPE

        if len(argv) > 0:
            bin_path = os.path.join('bin', sanitize_path(argv[0]))
        else:
            bin_path = ''

        if os.path.isfile(bin_path):
            argv[0] = bin_path
        else:
            argv.insert(0, 'bin/rand')

        try:
            processes.append(subprocess.Popen(argv,
                                              stdin=stdin,
                                              stdout=stdout,
                                              stderr=subprocess.PIPE,
                                              env=env))
        except PermissionError:
            pass
        except FileNotFoundError as e:
            return (e.errno, '', str(e))

        if stdout != subprocess.PIPE:
            stdout.close()

    try:
        (stdout, stderr) = processes[-1].communicate(timeout=TIMEOUT)
        status = processes[0].wait()
    except subprocess.TimeoutExpired:
        processes[-1].kill()
        _ = processes[-1].communicate()
        return (255, '', 'timed out after {} seconds'.format(TIMEOUT))

    if stdout:
        stdout = stdout.decode('utf-8')
    else:
        stdout = ''

    return (status, stdout, stderr.decode('utf-8'))

def ensure_dir(d):
    try:
        os.mkdir(d)
    except OSError:
        pass

# from http://news.anarchy46.net/2012/01/irc-message-regex.html
MSG_RE = re.compile(r'^(:(?P<prefix>\S+) )?(?P<command>\S+)( (?!:)(?P<params>.+?))?( :(?P<trail>.+))?$')
PREFIX_RE = re.compile(r'(?P<nick>\S+)!(?P<user>\S+)@(?P<host>\S+)')

config = configparser.ConfigParser()
config.read('etc/irsh.ini')
config = config['irsh']
HOST = config['host']
PORT = int(config['port'])
NICK = config['nick']
USER = config['user']
LEADER = config['leader']
MAXPIPES = int(config['maxpipes'])
TIMEOUT = int(config['timeout'])

log = logging.getLogger(__name__)
log.addHandler(logging.StreamHandler(sys.stderr))
log.setLevel(logging.DEBUG)

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))
sf = s.makefile()

ensure_dir('var')

send('PASS {}'.format(getpass.getpass()), False)
send('NICK {}'.format(NICK))
send('USER {}'.format(USER))

cmd_fifo = open_cmd_fifo()

while True:
    try:
        msg = recv()
        prefix, command, params, trail = parse_msg(msg)
        if command == "001":
            try:
                with open('var/chans') as chans:
                    for chan in chans:
                        chan = chan.rstrip()
                        try:
                            os.makedirs(path.chan_path(chan, ''))
                        except OSError:
                            pass
                        send('JOIN {}'.format(chan))
            except OSError:
                pass
        elif command == 'PING':
            send('PONG :{}'.format(trail))
        elif command == 'PRIVMSG':
            nick, _, _ = parse_prefix(prefix)
            if is_ignored(nick):
                continue
            target = params
            msg = trail

            if target == NICK:
                channel = nick
            else:
                channel = target

            env = { 'NICK': nick, 'CHAN': channel, 'PATH': os.environ['PATH'] }

            for f in glob.glob('lib/filter/*'):
                argv = [f, msg]
                try:
                    subprocess.Popen(argv, env=env).communicate()
                except PermissionError:
                    pass

            if msg.startswith(LEADER):
                commandline = msg[len(LEADER):]
                status, stdout, stderr = run(commandline, env)
                log.info('[{}]\nstdout:\n{}\nstderr:\n{}'
                            .format(status, stdout, stderr))
                resp = stdout.rstrip().replace('\n', ' | ') + stderr.rstrip().replace('\n', ' | ')
                if resp:
                    resp = 'PRIVMSG {} :{}'.format(channel, resp).encode('utf-8')
                    if len(resp) > 510:
                        resp = resp[:510]
                    send(resp.decode('utf-8', 'ignore'))
                with open('var/status', 'w') as f:
                    f.write('{}\n'.format(status))

            cmds = cmd_fifo.readlines()
            for cmd in cmds:
                send(cmd.rstrip())
    except UnicodeDecodeError as e:
        log.error("{}".format(e))
        continue
