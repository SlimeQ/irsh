#!/usr/bin/env python3

import configparser
import html
import logging
import os
import path
import re
import shlex
import subprocess
import sys
import glob
import getpass
from matrix_client.client import MatrixClient

def is_ignored(username):
    try:
        with open('etc/ignore', 'r') as f:
            for line in f:
                if line.rstrip() == username:
                    return True
    except OSError:
        pass
    return False

def sanitize_path(path):
    return path.replace('/', '')

def run(commandline, env):
    commands = [re.sub(r'\\\|', '|', s) for s in re.split(r'(?<!\\)\|', commandline)]

    if len(commands)-1 > MAXPIPES:
        return (255, '', 'exceeded maximum number of pipes ({})'.format(MAXPIPES))

    processes = []

    for i, command in enumerate(commands):

        if i == 0:
            stdin = subprocess.DEVNULL
        else:
            stdin = processes[i - 1].stdout

        try:
            argv = shlex.split(command)
        except ValueError as e:
            return (255, '', str(e))

        if '>>' in argv:
            j = argv.index('>>')
            argv.pop(j)
            try:
                chan_path = path.chan_path(env['CHAN'], argv.pop(j))
                stdout = open(chan_path, 'a+')
            except IndexError:
                return (255, '', 'bad redirect')
            except OSError as e:
                return (e.errno, '', str(e))
        else:
            stdout = subprocess.PIPE

        if len(argv) > 0:
            bin_path = os.path.join('bin', sanitize_path(argv[0]))
        else:
            bin_path = ''

        if os.path.isfile(bin_path):
            argv[0] = bin_path
        else:
            argv.insert(0, 'bin/rand')

        try:
            processes.append(subprocess.Popen(argv,
                                              stdin=stdin,
                                              stdout=stdout,
                                              stderr=subprocess.PIPE,
                                              env=env))
        except PermissionError:
            pass
        except FileNotFoundError as e:
            return (e.errno, '', str(e))

        if stdout != subprocess.PIPE:
            stdout.close()

    try:
        (stdout, stderr) = processes[-1].communicate(timeout=TIMEOUT)
        status = processes[0].wait()
    except subprocess.TimeoutExpired:
        processes[-1].kill()
        _ = processes[-1].communicate()
        return (255, '', 'timed out after {} seconds'.format(TIMEOUT))

    if stdout:
        stdout = stdout.decode('utf-8')
    else:
        stdout = ''

    return (status, stdout, stderr.decode('utf-8'))

def ensure_dir(d):
    try:
        os.mkdir(d)
    except OSError:
        pass

def room_message_listener(e):
    nick = e['sender']
    if is_ignored(nick):
        return
    channel = e['room_id']
    msg = e['content']['body']
    env = { 'NICK': nick, 'CHAN': channel, 'PATH': os.environ['PATH'] }

    ensure_dir(path.chan_path(channel, ''))

    for f in glob.glob('lib/filter/*'):
        argv  = [f, msg]
        try:
            subprocess.Popen(argv, env=env).communicate()
        except PermissionError:
            pass

    if msg.startswith(LEADER):
        commandline = msg[len(LEADER):]
        status, stdout, stderr = run(commandline, env)
        log.info('command:{} status:{} stdout:{} stderr:{}'.format(repr(commandline), status, repr(stdout), repr(stderr)))
        stdout = stdout.rstrip()
        stderr = stderr.rstrip()
        response = stdout
        if status != 0 and stderr:
            if stdout:
                response += "\n"
            response += stderr
        if response:
            fmt = '<pre><code>{}</code></pre>' if '\n' in response else '<code>{}</code>'
            client.get_rooms()[channel].send_html(fmt.format(html.escape(response)), body=response)
        with open('var/status', 'w') as f:
            f.write('{}\n'.format(status))

def event_listener(e):
    log.info('event:{}'.format(e))
    try:
        if e['type'] == 'm.room.message' and e['content']['msgtype'] == 'm.text':
            room_message_listener(e)
    except KeyError as k:
        log.error("Missing key {} in message: {}".format(k, e))
    except Exception as x:
        log.error("Squashing exception: {}".format(x))

def invite_listener(room_id, state):
    log.info('invite:{}'.format(room_id))
    client.join_room(room_id)

def leave_listener(room_id, room):
    log.info('leave:{}'.format(room_id))

log = logging.getLogger(__name__)
log.addHandler(logging.StreamHandler(sys.stderr))
log.setLevel(logging.DEBUG)

config = configparser.ConfigParser()
config.read('etc/irsh.ini')
config = config['irsh']
URL = config['url']
USERNAME = config['username']
if 'password' in config:
    log.warning('using plaintext password from config file')
    PASSWORD = config['password']
else:
    PASSWORD = getpass.getpass()
LEADER = config['leader']
MAXPIPES = int(config['maxpipes'])
TIMEOUT = int(config['timeout'])

ensure_dir('var')
ensure_dir('var/root')

client = MatrixClient(URL)
try:
    client.register_with_password(username=USERNAME, password=PASSWORD)
except:
    pass
client.login(username=USERNAME, password=PASSWORD)
client.add_listener(event_listener)
client.add_invite_listener(invite_listener)
client.add_leave_listener(leave_listener)
client.listen_forever()
